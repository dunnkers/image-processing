\documentclass{article}
\usepackage{styles}

\title{Image Processing\\
    Lab 3}
\author{Kevin Gevers (s25595987) \\ Jeroen Overschie (s2995697)}
\date{\today}

\begin{document}

\maketitle

Note, that all used source code can be found attached next to this report's pdf file. Its structure should be self-explanatory; all requested functions are named accordingly and any extra functions are explained in the report. Note that (almost) every function has a corresponding test script, which is named just like its function, but with a suffix '\texttt{\_test}'. Where possible, we followed the terminology from the book \citep{gonzalez2008digital} for variable naming.

\section*{Exercise 1}
First some basic theory on the subject. We are given some grey scale image, $f$. We now denote the Laplacian pyramid of f using:
\[
    f_1 = f
\]
\[
\begin{aligned}
    f_j = \textsc{REDUCE}(f_{j-1}) & \text{  for $j=2,...J$}
\end{aligned}
\]

Please do denote the subtle differences between the lowercase $j$ and uppercase $J$. $J$ denotes the number of levels of the pyramid composition, e.g. when $J = 3$, the pyramid will consist out of 3 images: the original, a decomposition of the original, and a decomposition of the decomposition. Furthermore, we define $d_1,d_2,...d_{J-1}$ as the \textit{detail signals}, or \textit{residuals}:

\[
\begin{aligned}
    d_j = f_j - \textsc{EXPAND}(f_{j+1}) & \text{  for $j=1,2,...J-1$}
\end{aligned}
\]

Which are more simply said the decompositions scaled back to the dimensions of their previous form, to then get the difference between the two images using matrix subtraction. Because we are diffing the images here, our vector $d$ can only be of length $J-1$. Lastly, we define the \textsc{REDUCE} and \textsc{EXPAND} operators:

\[
    \textsc{REDUCE}(f) = \downarrow_2 (h_\sigma * f)
\]
\[
    \textsc{EXPAND}(f) = h_\sigma * (\uparrow_2 (f)),
\]

where $h_\sigma$ denotes \textit{Gaussian filtering}, which is a filter with a Gaussian response that can be used for performing a sort of image blur. The filter has the parameter $\sigma$, which is the standard deviation of the kernel. Furthermore, the operations denoted by the arrows, $\downarrow_2$ and $\uparrow_2$ denote \textbf{shrinking} and \textbf{zooming} an image by a factor $2$, respectively. In the spirit of maximum re-usability and efficiency, we reused some functions from Exercise 1 for this: the 'fundamental' functions \textsc{IPinterpolate} and \textsc{IPscaling\_transformation} to do the scaling work, and \textsc{IPdownsample} and \textsc{IPzoom} to apply them. These functions are thoroughly documented in the first report. In this lab, we use \textsc{IPdownsample} for our shrinking functionality ($\downarrow_2$) and \textsc{IPzoom} for zooming functionality ($\uparrow_2$).

\subsection*{(a)} In this first exercise, we were asked to implement a function \textsc{IPpyr\_decomp} that builds a Laplacian pyramid decomposition. For the parameters of this function, $f$ is the input image, $J$ the composition level and $\sigma$ the Gaussian filter kernel parameter. For our implementation, see \ding{118} Listing \ref{code:IPpyr_decomp}.

In our implementation, we use matlab \textit{Cell} types to store the pyramid and the detail signals, in variables $f$ and $d$, respectively. Note that the Matlab cell type indeed makes it possible to store matrices of variable lengths, though we do need the function \textsc{mat2cell} and \textsc{cell2mat} for storing/retrieving from the cell array. Like announced, we were allowed to use the function \textsc{imgaussfilt} to perform the Gaussian filtering process. We hand it a double image (\textsc{im2double}) and the parameter $\sigma$. We perform both the Reducing and Expanding operations and store the residuals in $d$.

Now finally, we can store the result in a matrix $g$. We can compute the height for this result matrix using:


\[
    P = M \times (1+\frac{1}{2}+(\frac{1}{2})^2+...+(\frac{1}{2})^{J-1}),
\]

which we conveniently implemented using an element-wise squaring operation in Matlab, i.e. using \texttt{.\^} (see code line 25). Next come some basic geometry operations to stack the result images vertically over the space of $P$ and centering each image horizontally over the space of $M$. This done, we result with a result matrix $g$, which  is also saved to \texttt{IPpyr\_decomp-g\_J=3,sigma=1.0.mat}.
\subsection*{(b)} Next, we visualize the results, using again a \texttt{*\_test} script. See Figure ~\ref{fig:plant_original} for the original image and Figure~\ref{fig:plant_all_pyr-decomp} for its Laplacian pyramid decomposition using $J=3$ and $\sigma=1.0$.

\begin{figure}[ht]
    \centering
    \includesvg[width=0.5\textwidth]{Assignment_3/output_plots/plant_original.svg}
    \caption{Original plant image for Exercise 1 without any filtering applied.}
    \label{fig:plant_original}
\end{figure}

\begin{figure}[ht]
    \centering
    \includesvg[width=\textwidth]{Assignment_3/output_plots/plant_all_pyr-decomp.svg}
    \caption{Laplacian pyramid decomposition of \ref{fig:plant_original} using $J=3$ and $\sigma=1.0$. Residuals $d$ are vertically stacked, with at the bottom the final decomposition, $f_{3}$.}
    \label{fig:plant_all_pyr-decomp}
\end{figure}

\subsection*{(c)} See \texttt{IPpyr\_decomp\_data-J=3,sigma=1.0.mat} for the result matrix data $g$.

\section*{Exercise 2}
\subsection*{(a)}
\subsection*{(b)}
\subsection*{(c)}
\subsection*{(d)}

\newpage
\bibliographystyle{plain}
\typeout{}
\bibliography{Assignment_3}

\appendix
\section{Code}
\subsection{Exercise 1}
\lstinputlisting[caption={\textsc{IPpyr\_decomp} function: Laplacian pyramid decomposition.}, label={code:IPpyr_decomp}]{Assignment_3/IPpyr_decomp.m}
\subsection{Exercise 2}
\subsubsection{Exercise 2 (a)}
\end{document}
